1. server should be robust & compatible for any language
2. server should only send data nothing else

server
mux -> gin



package clienthandlers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/prachin77/db"
	"github.com/prachin77/server/models"
	"github.com/prachin77/server/utils"
)

func Login(ctx *gin.Context) {

	ctx.Header("content-Type", "text/html")
	ctx.Header("content-Type", "application/json")

	var user models.User
	err := json.NewDecoder(ctx.Request.Body).Decode(&user)
	if err != nil {
		fmt.Println("data not in correct format")
		ctx.Writer.WriteHeader(http.StatusBadRequest)
		return
	}

	// check for empty data
	if user.Email == "" || user.Password == "" {
		fmt.Println("email & password can't be empty")
		ctx.Writer.WriteHeader(http.StatusBadRequest)
		return
	}

	// check through email & pasword if user found  in db or not
	userFound, storedUser := db.CheckUserInDB(&user)
	if !userFound {
		fmt.Println("message no user found in db")
		ctx.Writer.WriteHeader(http.StatusBadRequest)
		return
	}

	utils.SetCookie(ctx, &storedUser)

	fmt.Println("login sucessfull")
	fmt.Println("login user details = ", storedUser)

	respInterface = map[string]interface{}{
		"message": "Login successful",
		"user":    storedUser,
	}
	fmt.Println(respInterface)
	ctx.Writer.WriteHeader(http.StatusOK)
	RenderHomePage(ctx)
}

func Register(ctx *gin.Context) {
	ctx.Header("content-Type", "text/html")

	var user models.User
	err := json.NewDecoder(ctx.Request.Body).Decode(&user)
	if err != nil {
		fmt.Println(err)
		ctx.Writer.WriteHeader(http.StatusBadRequest)
		return
	}

	if user.UserName == "" || user.Email == "" || user.Password == "" {
		fmt.Println("any of the fields can't be empty")
		ctx.Writer.WriteHeader(http.StatusBadRequest)
		return
	}

	// check if user is present in db or not
	userFound, _ := db.CheckUserInDB(&user)
	if userFound == true {
		resp["message"] = "user found in db !"
		ctx.Writer.WriteHeader(http.StatusConflict)
		return
	}

	tokenString := utils.TokenGenerator()
	// Checking whether the generated session token is already used or not
	// If so then generate another session token & keep this loop until we find a unique session token
	for {
		isTokenFound, err := db.IsTokenPresentInDb(tokenString)
		if err != nil {
			fmt.Println(err)
			fmt.Println("can't validate token")
		}
		if !isTokenFound {
			break
		}
		tokenString = utils.TokenGenerator()
		fmt.Println("new session token : ", tokenString)
	}
	user.UserId = tokenString

	err, insertedUser := db.InsertUser(&user)
	if err != nil {
		fmt.Println("error inserting data")
		ctx.Writer.WriteHeader(http.StatusInternalServerError)
		return
	}
	utils.SetCookie(ctx, &insertedUser)
	fmt.Println("Registration successful")
	fmt.Println("Inserted user details: ", insertedUser)
	ctx.Writer.WriteHeader(http.StatusOK)
	RenderHomePage(ctx)
}




{
    "web":{
        "client_id":"212525301717-2ql13k6c2sj7ucsmtj9btb2rtqkcfbfr.apps.googleusercontent.com",
        "project_id":"blogweb-9b28d",
        "auth_uri":"https://accounts.google.com/o/oauth2/auth",
        "token_uri":"https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs",
        "client_secret":"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",
        "redirect_uris":["https://cloud.appwrite.io/v1/account/sessions/oauth2/callback/google/66c5f59a0005c919a7c1"],
            "javascript_origins":["http://localhost:1234"]    
    }
} 


